# -*- coding: utf-8 -*-
"""Task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zMtjtjWHmgKDj6-wZHWN6M8nOSYDTD33
"""

import networkx
import matplotlib.pyplot as plt

# ---------------------------
# Задание 1

G = networkx.read_gexf('vk_friends_graph.gexf') # считали файл, такой же метод как в первой части, только другой формат

# визуализация графа для понимания происходящего, не входит в задание
plt.figure(figsize=(15,15)) 
plt.title('Граф')
networkx.draw(G, node_size=5)
plt.show()

G_weak = G.subgraph(max(networkx.weakly_connected_components(G), key=len)) # получаем необходимую компоненту связности как в задании

# не входит в задание
print('Количество вершин:', G_weak.number_of_nodes()) # выводим количество вершин
print('Количество рёбер:', G_weak.number_of_edges()) # выводим количество рёбер
print('Средняя степень:', round(2 * G_weak.number_of_edges() / G_weak.number_of_nodes(), 2)) # выводим среднюю степень для вершин

degree_centr = networkx.degree_centrality(G_weak) # считаем необходиму метрику
#print(degree_centr)
sorted_tuple = sorted(degree_centr.items(), key=lambda x: x[1], reverse=True) # сортируем полученный словарь по значению от большего к меньшему (reverse=True)
#print(sorted_tuple[0:10])
for i in sorted_tuple[:10]: # бегаем по первым 10 значениям в отсортированном словаре
   print(i[0], end=' ') # печатаем ключ(id друга) на экран
#print()
#print() # пустые строчки

# аналогично для всех метрик

closeness_centr = networkx.closeness_centrality(G_weak)
#print(closeness_centr)
sorted_tuple2 = sorted(closeness_centr.items(), key=lambda x: x[1], reverse=True)
#print(sorted_tuple2[:10])
for i in sorted_tuple2[:10]:
  print(i[0], end=' ')
print()
print()

betweenness_centr = networkx.betweenness_centrality(G_weak)
#print(betweenness_centr)
sorted_tuple3 = sorted(betweenness_centr.items(), key=lambda x: x[1], reverse=True)
#print(sorted_tuple3[:10])
for i in sorted_tuple3[:10]:
  print(i[0], end=' ')
print()
print()

eigenvector_centr = networkx.eigenvector_centrality(G_weak, max_iter=600)
#print(eigenvector_centr)
sorted_tuple4 = sorted(eigenvector_centr.items(), key=lambda x: x[1], reverse=True)
#print(sorted_tuple4[:10])
for i in sorted_tuple4[:10]:
  print(i[0], end=' ')
print()
print()

# ---------------------------
# Задание 2

m = networkx.adjacency_matrix(G) # получаем матрицу смежности, каждая строка это друг, в столбиках да/нет (0/1) дружба по всем друзьям

#a = networkx.convert.to_dict_of_dicts(G)
#print(a)
#print(m)
norm_m = m.todense() # приводим матрицу к челоевческому виду
#print(norm_m)
nod = list(G.nodes()) # понадобится список всех вершин (id друзей)
#print(nod)

# print(norm_m[2])
# print(norm_m[4])
#print(norm_m[12])
#print(norm_m[nod.index('494289203')])

from numpy import dot, asarray, squeeze, array
from numpy.linalg import norm
from sklearn.metrics.pairwise import cosine_similarity

degree_centr_G = networkx.degree_centrality(G)
closeness_centr_G = networkx.closeness_centrality(G)
betweenness_centr_G = networkx.betweenness_centrality(G)
eigenvector_centr_G = networkx.eigenvector_centrality(G, max_iter=600)





norm_m = asarray(norm_m)
#print(type(norm_m[0]))
d = dict()
for i in range(len(nod)-1):
  for j in range(i+1, len(nod)):
    result=cosine_similarity(norm_m[i].reshape(1,-1), norm_m[j].reshape(1,-1))
    d[f"{nod[i]} - {nod[j]}"] = result
#print(d)
sorted_dict = sorted(d.items(), key=lambda x: x[1], reverse=True)
for i in sorted_dict[0:5]:
  #print(f'{i[0]} : {round(float(i[1]),2)}')
  ls_2 = list(i[0].split())
  print(f"{ls_2[0]} : degree_centrality: {degree_centr_G[ls_2[0]]}, closeness_centrality: {closeness_centr_G[ls_2[0]]}, betweenness_centrality: {betweenness_centr_G[ls_2[0]]}, eigenvector_centrality: {eigenvector_centr_G[ls_2[0]]}")
  print(f"{ls_2[2]} : degree_centrality: {degree_centr_G[ls_2[2]]}, closeness_centrality: {closeness_centr_G[ls_2[2]]}, betweenness_centrality: {betweenness_centr_G[ls_2[2]]}, eigenvector_centrality: {eigenvector_centr_G[ls_2[2]]}")
  print()

# ---------------------------
# Задание 3

# Различаются, потому что две идеально близкие вершины (сходство = 1) могут представлять собой отдельную компоненту связности, 
                                                          #не включающую в себя никакие другие вершины
# В таком случае будет одно ребро, связывающее две вершины. Отсюда пониманием, что будут малые метрики центральности.

