# -*- coding: utf-8 -*-
"""Task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LJxFNNfx0Z2phOdB7xFYIRasevg3IbTd
"""

import networkx # библиотека для работы с графами
import matplotlib.pyplot as plt # библиотека для работы с графиками
import numpy # библиотека для создания массивов (удобно для графиков)

# ---------------------------
# Задание 1

G = networkx.read_gml('netscience.gml') # считываем граф из файла
# G = networkx.Graph() # создаём объект графа
# G.add_edge('A', 'B') # в нем строим ребро А-В
# G.add_edge('B', 'C') # и B-C

sr_st = round(2 * G.number_of_edges() / G.number_of_nodes(), 2) # в отдельную переменную выносим значение среднего

print('Количество вершин:', G.number_of_nodes()) # выводим количество вершин
print('Количество рёбер:', G.number_of_edges()) # выводим количество рёбер
print('Средняя степень:', sr_st) # выводим среднюю степень для вершин

# ---------------------------
# Задание 2

#print(G.degree) # выводим список из пар (имя_вершины, кол-во рёбер исходящих из нее). Это для удобства, по факту не нужно
ls = G.degree # завели этот список в переменную для дальнейшей работы

# далее считаем количество вершин, у которых степень больше среднего

count = 0 # до начала работы счётчик = 0
for i in ls: # цикл, где каждый раз i принимает значение (т.е. пару) из списка ls
    if i[1] > sr_st: # если её степень, а она на втором месте в паре, больше среднего, то...
        count = count + 1 # то счетчик увеличиваем на один
print(count) # выводим на экран

# ---------------------------
# Задание 4

G2 = G.subgraph(max(networkx.connected_components(G), key=len))
print('Радиус :', networkx.radius(G2)) # вывод радиуса и диаметра у графа
print('Диаметр :', networkx.diameter(G2))

# ---------------------------
# Задание 3

degree_free = numpy.array(networkx.degree_histogram(G)) # создаем массив, по которому будет строиться гистограмма
plt.stem(degree_free) # придаем вид для гистограммы
plt.xlabel('Степени') # подписываем оси
plt.ylabel('Количество вершин')
plt.show() # выводим на экран

#print(sr_st * 2)

# ---------------------------
# Задание 4

sp = networkx.all_pairs_shortest_path_length(G) # собираем в неведомый контейнер самые коротки расстояния (= расстояния) для всевозможных пар
ls2 = list() # список, где будем хранить значения расстояний, пока пустой
a = dict(sp) # из неведомого контейнера делаем словарик, с ним удобнее работать
#print(a)
ls_nodes = list(G.nodes) # получаем список всех вершин в нашем графе
#print(ls_nodes)
for i in range(len(ls_nodes)-1): # пробегаемся по первому элементу в паре, от 0 места до предпоследнего
   for j in range(i+1, len(ls_nodes)): # по второму, от следующего после первого и до последнего
     if ls_nodes[j] in a[ls_nodes[i]]: # а есть ли вообще такая пара? Можно ли прийти из первой вершины до второй? Есть ли расстояние?
       ls2.append(a[ls_nodes[i]][ls_nodes[j]]) # ну если есть, то добавим её в список
#print(ls2) 
#main1 = numpy.array(ls2) # теперь нужен не просто список, а вектор. Там есть метод для подсчета процентиля
#print(main1)
main2 = numpy.percentile(main1, 90) # считаем процентиль
print(main2)